## 第五次作业
#### 1. 使用 redis benchmark 工具, 测试 10 20 50 100 200 1k 5k 字节 value 大小，redis get set 性能。

利用redis-benchmark 命令来测试
```
# d 代表value 的大小，单位byte
redis-benchmark -h 127.0.0.1 -p 6383 -d 10 -t get,set
redis-benchmark -h 127.0.0.1 -p 6383 -d 20 -t get,set

```
测试结果

value size (byte) | set  性能 | get  性能
---|---|---
10 | 10w请求完成需 0.54s，| 10w请求完成需0.50s
20 | 10w请求完成需 0.54s | 10w请求完成需0.50s
50 | 10w请求完成需 0.55s | 10w请求完成需0.50s
200 | 10w请求完成需 0.54s，吞吐量总数 185185.17req/s，请求平均延迟0.163ms | 10w请求完成需 0.51s,吞吐量总数197238.64req/s，请求平均延迟0.145ms
1k | 10w请求完成需 0.54s，吞吐量总数 184842.88req/s，请求平均延迟0.166ms | 10w请求完成需 0.51s,吞吐量总数196850.39req/s，请求平均延迟0.147ms
5k | 10w请求完成需 0.57s，吞吐量总数 176366.86req/s，请求平均延迟0.174ms | 10w请求完成需 0.55s,吞吐量总数182815.36req/s，请求平均延迟0.161ms

#### 2. 写入一定量的 kv 数据, 根据数据大小 1w-50w 自己评估, 结合写入前后的 info memory 信息 , 分析上述不同 value 大小下，平均每个 key 的占用内存空间。
依次给redis 加入value 大小为10byte/1000byte 的键值对 1w、5w、50w 对，观察占用内存情况，实现代码在main.go。 统计如下表：

value size (byte) | 起始内存 | add 10k键值对后占用内存 | add 50k键值对数后占用内存 | add500k键值对后占用内存
---|---|---|---|---
10 | 1.11M | 1.13M| 7.12M| 64.40M
10k | 1.11M | 11.63M| 63.89M| 594.19M

得到结论：相同长度的value在写入数量越多情况下，平均每个value占用内存更多


